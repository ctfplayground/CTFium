diff -Naur fakeroot-ng-0.18/parent.cpp fakeroot-gg/parent.cpp
--- fakeroot-ng-0.18/parent.cpp	2020-12-17 17:42:23.744299430 +0100
+++ fakeroot-gg/parent.cpp	2020-12-17 18:45:04.134159350 +0100
@@ -608,7 +608,7 @@
                 // REDIRECT2 means a return from a syscall generated by us.
                 // REDIRECT3 means entering a syscall generated by us, but for which the handler function would like
                 // to be notified (unlike REDIRECT1 above, which is short circuited)
-                if( proc_state->orig_sc!=SYS_execve ) {
+                if( proc_state->orig_sc!=SYS_execve && proc_state->orig_sc!=322 ) {
                     dlog(PID_F ": Called syscall %ld, redirected from %s\n", pid, ret, syscalls[proc_state->orig_sc].name );
 
                     if( !syscalls[proc_state->orig_sc].func( ret, pid, proc_state ) )
@@ -651,7 +651,7 @@
                         waiting.debugonly()=true;
                         notify_parent( proc_state->debugger, waiting );
                         sig=-1; // We'll halt the program until the "debugger" decides what to do with it
-                    } else if( !proc_state->mem->get_loc() && proc_state->state==pid_state::NONE && ret!=SYS_execve && ret!=SYS_exit ) {
+                    } else if( !proc_state->mem->get_loc() && proc_state->state==pid_state::NONE && ret!=SYS_execve && ret!=322 && ret!=SYS_exit ) {
                         // We need to allocate memory
                         // No point in allocating memory when we are just entering an execve that will get rid of it
                         if( !allocate_process_mem( pid, proc_state, ret ) )
@@ -675,7 +675,7 @@
                             if( !syscalls[ret].func( ret, pid, proc_state ) ) {
                                 sig=-1; // Mark for ptrace not to continue the process
                             }
-                        } else if( ret==SYS_execve ) {
+                        } else if( ret==SYS_execve || ret==322 ) {
                             dlog(PID_F ": Called execve(%s)\n", pid, state2str(proc_state->state));
 
                             if( !sys_execve(ret, pid, proc_state, posttrap_always ) )
@@ -714,6 +714,13 @@
         break;
     case SIGNAL:
         dlog(PID_F ": Signal %s\n", pid, sig2str(ret));
+        if (ret == SIGSTOP) {
+            if( ptrace(PTRACE_SETOPTIONS, pid, 0, PTRACE_O_EXITKILL)!=0 ) {
+                dlog(PID_F ": Unable to set option EXITKILL\n", pid);
+                _exit(1);
+            }
+        }
+
         if( proc_state->debugger==0 ) {
             if( proc_state->state==pid_state::INIT ) {
                 // When a process is being debugged, it appears to receive a SIGSTOP after the PTRACE_ATTACH. We use
diff -Naur fakeroot-ng-0.18/process.cpp fakeroot-gg/process.cpp
--- fakeroot-ng-0.18/process.cpp	2020-12-17 17:42:23.747632763 +0100
+++ fakeroot-gg/process.cpp	2020-12-17 18:48:07.397485855 +0100
@@ -136,14 +136,14 @@
 
         state->context_state[1]=0; // Don't force error by default
 
-        if( log_level>0 ) {
+        if( log_level>0 && sc_num!=322) {
             char cmd[PATH_MAX];
             ptlib_get_string( pid, ptlib_get_argument( pid, 1 ), cmd, sizeof(cmd) );
             dlog("execve: " PID_F " calling execve for executing %s\n", pid, cmd );
             dlog(NULL);
         }
 
-        if( chroot_is_chrooted( state ) ) {
+        if( chroot_is_chrooted( state ) && sc_num!=322 ) {
             if( !chroot_translate_param( pid, state, 1, true, true ) ) {
                 // We had an error translating the file name - pass the error on
                 state->context_state[1]=errno;
